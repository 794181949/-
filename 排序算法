1.冒泡排序：冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。
#include <stdio.h>
void bubble_sort(int arr[], int len)
{
  int i, j, temp;
  for (i=0; i<len -1; i++)
    for (j=0; j<len-1 - i; j++)
      if (arr[j] > arr[j+1])
      {
        temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
       }
 }
 int main(){
  int arr[] = {22,32,42,523,212,53};
  int len = (int) sizeof(arr)/ sizeof(*arr);
  bubble_sort(arr,len);
  int i;
  for (i=0; i <len; i++)
    printf("%d", arr[i]);
   return 0;
  }
2.选择排序：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
void swap (int *a, int*b)
{
  int temp = *a;
  *a = *b;
  *b = temp;
 }
 void selection_sort(int arr[], int len)
 {
  int i,j;
  for (i = 0; i< len-1; i++)
  {
    int min = i;
    for (j =i+1; j<len; j++) //走访所有未排序的元素
      if (arr[j]<arr[min]) //找到目前最小值
        min = j; //记录最小值
        swap(&arr[min],&arr[i]);//交换位置
    }
   }
   
   3.插入排序：它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，
   找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），
   因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
   void insertion_sor(int arr[], int len){
    int i, j, temp;
    for ( i =1; i<len; i++){
      temp = arr[i]； //暂时的数字是i位置的
      for (j = i; j>0 && arr[j-1]>temp; j--) // 当j-1位置的数字比i位置的数字大的时候，j位置的等于j-1位置的数字
        arr[j] = arr[j-1];//把已排序的元素逐步后移
      arr[j] = temp;
     }
    }
    
    4.希尔排序：希尔排序是基于插入排序的以下两点性质而提出改进方法的：
1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

void shell_sort(int arr[], int len){
  int gap, i ,j;
  int temp;
  for (gap = len >>1; gap > 0; gap =gap>>1)
    for ( i = gap; i < len; i++){
      temp = arr [i];
      for ( j = i - gap; j >= 0 && arr[j] > temp; j -= gap)
        arr[j+gap] = arr[j]; //前面的比后面的大，就让后面的等于前面的数字
       arr[j+gap] = temp; 
     }
   }
   
   归并排序：把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾
   int min(int x, int y){ //迭代法
    return x<y ? x:y;
   }
   void merge_sort(int arr[], int len){
    int* a = arr;
    int*b = (int*) malloc(len *sizeof(int));
    int seg, start;
    for (seg = 1; seg < len; seg +=seg){
      for(start = 0; start < len; start +=seg +seg){
        int low = start, mid = min( start + seg, len), high = min(start + seg +seg, len);
        int k = low;
        int start1 = low, end1 = mid;
        int start2 = mid, end2 = high;
        while (start1 < end 1 && start2 < end2)
          b[k++] = a[start1]<a[start2]?a[start1++]:a[start2++];
        while (start < end1)
          b[k++] = a[start1++];
        while (start2 <end2)
          b[k++] = a[start2++];
      }
      int* temp = a;
      a = b;
      b = temp;
    }
    if (a != arr){
      int i;
      for (i = 0; i < len; i++)
        b[i] = a[i];
      b = a;
    }
    free(b);
  }
        
//递归法

